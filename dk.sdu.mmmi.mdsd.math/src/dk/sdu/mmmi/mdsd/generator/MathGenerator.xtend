/*
 * generated by Xtext 2.25.0
 */
package dk.sdu.mmmi.mdsd.generator

import dk.sdu.mmmi.mdsd.math.Div
import dk.sdu.mmmi.mdsd.math.LetBinding
import dk.sdu.mmmi.mdsd.math.MathExp
import dk.sdu.mmmi.mdsd.math.MathNumber
import dk.sdu.mmmi.mdsd.math.Minus
import dk.sdu.mmmi.mdsd.math.Mult
import dk.sdu.mmmi.mdsd.math.Plus
import dk.sdu.mmmi.mdsd.math.VarBinding
import dk.sdu.mmmi.mdsd.math.VariableUse
//import java.util.HashMap
import java.util.Map
import javax.swing.JOptionPane
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import dk.sdu.mmmi.mdsd.math.Program
import dk.sdu.mmmi.mdsd.math.Expression
import dk.sdu.mmmi.mdsd.math.Parenthesis
import dk.sdu.mmmi.mdsd.math.ExternalUse
import dk.sdu.mmmi.mdsd.math.External
//import org.eclipse.emf.common.util.EList
import java.util.HashMap
import java.util.ArrayList

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathGenerator extends AbstractGenerator {
	
	//static Map<String, Integer> variables;

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val program = resource.allContents.filter(Program).next
		
		generateProgram(program, fsa)
		
		//val result = math.compute
		//result.displayPanel
		
	}
		
	def void displayPanel(Map<String, Integer> result) {
		var resultString = ""
		for (entry : result.entrySet()) {
         	resultString += "var " + entry.getKey() + " = " + entry.getValue() + "\n"
        }
		
		JOptionPane.showMessageDialog(null, resultString ,"Math Language", JOptionPane.INFORMATION_MESSAGE)
	}
	
	def static generateProgram(Program prog, IFileSystemAccess2 fsa) {
		fsa.generateFile('''math_expression/«prog.name».java''', generateMath(prog))
	}
	
	def static generateMath(Program prog) {
		val name = prog.name
		
		return '''
			package math_expression;
			
			import java.util.*;
			
			public class «name» {
				«generateScopingMechanism()»
				
				«generateAttributes(prog)»
				
				public «name»(«IF prog.ext.size != 0»External external«ENDIF») {
					«IF prog.ext.size != 0»this.external = external;«ENDIF»
				}
				
				«generateCompute(prog.math)»
				«IF prog.ext.size != 0»«generateExternalInterface(prog)»«ENDIF»
			}
		'''
	}
	
	def static generateAttributes(Program prog) {
		val math = prog.math
		
		return '''
			«FOR m:math.variables»
			public int «m.name»;
			«ENDFOR»
			
			«IF prog.ext.size != 0»private External external;«ENDIF»
		'''
	}
	
	def static generateCompute(MathExp math) {
		return '''
			public void compute() {
				Scope scope0 = new Scope();
				«FOR v:math.variables» 
				«generateBinding(v, 0)»
				«ENDFOR»
			}
		'''
	}
	
	def static dispatch String generateBinding(VarBinding bind, Integer scopeLevel) {
		var ret = '''
		{
		«generateScopes(bind.expression, 0)»
		'''
		ret += '''
		«bind.name» = «generateExpression(bind.expression, 0)»;
		scope0.vars.put("«bind.name»", «bind.name»);
		}
		'''
		return ret
	}
	
	
	def static dispatch String generateBinding(LetBinding bind, Integer scopeLevel) {
		val ret = '''
		Scope scope«scopeLevel» = new Scope();
		scope«scopeLevel».vars.put("«bind.name»", «generateExpression(bind.binding, scopeLevel-1)»);
		scope«scopeLevel».parentScope = scope«scopeLevel-1»;
		'''
		return ret;
	}
	
	def static String generateExpression(Expression exp, Integer scopeLevel) {
		switch exp {
			Plus: '''«generateExpression(exp.left, scopeLevel)»+«generateExpression(exp.right, scopeLevel)»'''
			Minus: '''«generateExpression(exp.left, scopeLevel)»-«generateExpression(exp.right, scopeLevel)»'''
			Mult: '''«generateExpression(exp.left, scopeLevel)»*«generateExpression(exp.right, scopeLevel)»'''
			Div: '''«generateExpression(exp.left, scopeLevel)»/«generateExpression(exp.right, scopeLevel)»'''
			MathNumber: '''«exp.value»'''
			Parenthesis: '''(«generateExpression(exp.exp, scopeLevel)»)'''
			VariableUse: '''scope«scopeLevel».getVar("«exp.ref.name»")'''
			LetBinding: '''«generateExpression(exp.body, scopeLevel+1)»'''
			ExternalUse: '''external.«exp.ref.name»(«exp.params.map[e | generateExpression(e, scopeLevel)].join(', ')»)'''
			default: ''''''
		}
	}
	
	def static String generateScopes(Expression exp, Integer scopeLevel) {
		switch exp {
			Plus: '''«generateScopes(exp.left, scopeLevel)» «generateScopes(exp.right, scopeLevel)»'''
			Minus: '''«generateScopes(exp.left, scopeLevel)» «generateScopes(exp.right, scopeLevel)»'''
			Mult: '''«generateScopes(exp.left, scopeLevel)» «generateScopes(exp.right, scopeLevel)»'''
			Div: '''«generateScopes(exp.left, scopeLevel)» «generateScopes(exp.right, scopeLevel)»'''
			Parenthesis: '''«generateScopes(exp.exp, scopeLevel)»'''
			LetBinding: '''«generateBinding(exp, scopeLevel+1)»
			«generateScopes(exp.body, scopeLevel+1)»'''
			ExternalUse: '''«exp.params.map[p | generateScopes(p, scopeLevel)].join('\n')»'''
			default: ''''''
		}
	}
	
	def static generateScopingMechanism() {
		
		return '''
			class Scope {
				public HashMap<String, Integer> vars = new HashMap<String, Integer>();
				public Scope parentScope = null;
				
				public Integer getVar(String n) {
					Integer i = vars.get(n);
					if(i == null) {
						if(parentScope == null)
							return null;
						return parentScope.getVar(n);
					}
					return i;
				}
			}
		'''
	}
	
	def static generateExternalInterface(Program prog) {
		var paramNumber = 0
		
		//var String[] paramStrings = newArrayList()
		var Map<String, ArrayList<String>> params = new HashMap();
		
		for(Expression e : prog.ext) {
			var ArrayList<String> paramStrings = new ArrayList<String>()
			params.put((e as External).name, paramStrings)
			for(String p : (e as External).params) { 
				val temp = params.get((e as External).name)
				temp.add('''«p» p«paramNumber++»''')
			}
		}
		
		return '''
			public interface External {
				«FOR e:prog.ext»
				public int «(e as External).name»(«params.get((e as External).name).join(',')»);
				«ENDFOR»
			}
		'''
	}
	
/*
 * «FOR p:(e as External).params»«p» « enumerator for variable name + remember separating comma»«ENDFOR»
 */

//	def static compute(MathExp math) {
//		variables = new HashMap()
//		for(varBinding: math.variables)
//			varBinding.computeExpression()
//		variables
//	}
//	
//	def static dispatch int computeExpression(VarBinding binding) {
//		variables.put(binding.name, binding.expression.computeExpression())
//		return variables.get(binding.name)
//	}
//	
//	def static dispatch int computeExpression(MathNumber exp) {
//		exp.value
//	}
//
//	def static dispatch int computeExpression(Plus exp) {
//		exp.left.computeExpression + exp.right.computeExpression
//	}
//	
//	def static dispatch int computeExpression(Minus exp) {
//		exp.left.computeExpression - exp.right.computeExpression
//	}
//	
//	def static dispatch int computeExpression(Mult exp) {
//		exp.left.computeExpression * exp.right.computeExpression
//	}
//	
//	def static dispatch int computeExpression(Div exp) {
//		exp.left.computeExpression / exp.right.computeExpression
//	}
//
//	def static dispatch int computeExpression(LetBinding exp) {
//		exp.body.computeExpression
//	}
//	
//	def static dispatch int computeExpression(VariableUse exp) {
//		exp.ref.computeBinding
//	}
//
//	def static dispatch int computeBinding(VarBinding binding){
//		if(!variables.containsKey(binding.name))
//			binding.computeExpression()			
//		variables.get(binding.name)
//	}
//	
//	def static dispatch int computeBinding(LetBinding binding){
//		binding.binding.computeExpression
//	}
	
}
